\chapter{Fundamentos te\'oricos}

\section{Antecedentes}

En el año 2011, Mayabiro E. presento en la Universidad Nacional Experimental del Táchira, un prototipo sobre el entorno MATLAB para el cálculo de la tasa de germinación de plántulas de pimentón previamente segmentadas. El entorno desarrollado permitió establecer una clasificación de las plántulas, hojas u objetos de la misma por medio de redes neuronales. Se realizo el entrenamiento de múltiples redes neuronales multicapas con algoritmos de retropropagación, donde aunque variaban las capas intermedias de las redes y sus funciones de transferencia fueron entrenadas con los mismos  datos de entrada, validandolas con una base de datos de pruebas para seleccionar al final una con salidas similares a las deseadas.\\

La clasificación por medio de redes neuronales ha sido un hito ya marcado en el campo agronómico, muchos estudios se han realizado con el objetivo de analizar ciertos comportamientos de plantas y los beneficios que se puedan sacar de ellas. En el año 2011, el grupo de investigación de sistemas de procesamiento y control de señales de la Universidad Nacional Tenaga de Malasia desarrollo un sistema de inteligencia con un enfoque novedoso para la clasificación de frutas usando técnicas de procesamiento de imágenes digitales y redes neuronales artificiales, con el objetivo de desarrollar un método de clasificación rápido con una meta del 100\% de eficiencia. El estudio se realizo con cinco frutas, manzanas, platanos, zanahorias, mangos y naranjas, extrayendo de ellas siete características en función de la forma y el color. La captura de las imágenes se realizo con una cámara digital convencional y las manipulaciones a los datos y construcción de la red con el software MATLAB. Los resultados obtenidos durante esta investigación fueron de gran avance en el campo de reconocimiento de patrones en imágenes.\\


Otro estudio realizado en el año 2013 por Stephen Gang Wu consistía en el estudio teórico de técnicas de procesamiento de imágenes y datos para el reconocimiento automático de hojas para la clasificación de plantas. Doce características de las plantas fueron extraídos y distribuidas en cinco variables principales que constituían el vector de entrada de una red neuronal artificial probabilista, que había sido entrenada con 1800 hojas para clasificar 32 tipos de plantas con una precision superior al 90\%, el autor asegura que su metodología de implementación de la PNN era fácil y rápida en comparación de otras investigaciones similares.\\

En el año 2017, Bernal N realizó un estudio de campo con el cultivo de papa criolla para evaluar la influencia de la densidad de siembra asociada a distancias entre plantas de 30,40 y 50 cm y distancias entre surcos de 100 cm sobre el conteo de tubérculos de calibres inferiores a 2 cm, entre 2 y 4 cm, entre 4 y 6 cm, y de mas de 6 cm de diámetro ponderado y sobre el peso fresco en gramos de los tubérculos. Los tubérculos cosechados se clasificaron y contaron mediante tamizado y se pesaron en su totalidad sin discriminar por calibre. Los modelos estadísticos empleados para modelar el comportamiento de la cosecha, evidenciaron el efecto significativo de la densidad de siembra sobre el conteo de tubérculos y calibre y se observo una razón aproximada de 40:40:20:1 desde el calibre menor al mayor. El efecto de la competición, en todos los modelos probados resulto significativo, aumentando en la mayoría de los casos a medida que disminuía la distancia entre plantas, tanto en el patrón de vecindad intrahileras como en el caso de inter e intrahileras.

\section{Bases Te\'oricas}

\subsection{Papa criolla (\textit{Solanum Phureja}).}

Las variables que influyen en el rendimiento de la papa pueden ser observados en la figura 2.1 \ref{fig:arch}. Pag.\pageref{fig:arch}.\\
\begin{figure}[h]
	\caption{Variables de influencia sobre el rendimiento de Solanum Phureja.}
	\centering
	\includegraphics[scale=0.5]{variables.png}
	\label{fig:arch}
\end{figure}

\subsection{Redes neuronales artificiales.}

Una red neuronal artificial,  es un conjunto de nodos de un programa (neuronas) interconectados entre si, simulando el proceso de pensamiento humano, se pudiera considerar como una caja negra entrenada previamente para esperar una entrada y basado en las características o comportamiento de la misma proporcionar una determinada salida, eliminando así la necesidad de diferentes algoritmos que deban analizar comportamientos cada uno por separado. Una red neuronal probabilística (PNN) no es mas que una ANN que usa funciones estadísticas que escalan la variable no linealmente como una forma de campana o una distribución normal (Stephen, 2007).\\

Entre las definiciones más recientes de inteligencia artificial se expresa, en forma general, la inteligencia artificial como la capacidad que tienen las máquinas para realizar tareas que en el momento son realizadas por seres humanos; otros autores como Nebendah (1988) y Delgado (1998) dan definiciones más completas y las definen como el campo de estudio que se enfoca en la explicación y emulación de la conducta inteligente en función de procesos computacionales basados en la experiencia y el conocimiento continuo del ambiente. Autores como Marr (1977), Mompin (1987), Rolston (1992), en sus definiciones involucran los términos de soluciones a problemas muy complejos.\\

El nacimiento de la inteligencia artificial se sitúa en los años cincuenta; en esa fecha la informática apenas se había desarrollado, y ya se planteaba la posibilidad de diseñar máquinas inteligentes. Hoy en día se habla de vida artificial, algoritmos genéticos, computación molecular o redes neuronales. En algunas de estas ramas los resultados teóricos van muy por encima de las realizaciones prácticas.\\

A través de los años, se han utilizado diversas técnicas de inteligencia artificial para emular 'comportamientos inteligentes'. Al software que hace uso de dichas técnicas se le denomina, de forma genérica, 'sistema inteligente', y es cada vez más amplia la gama de aplicaciones financieras donde incide la inteligencia artificial.\\

Un ejemplo de esto es que al usarse una tarjeta de crédito, suelen acumularse datos sobre patrones de consumo que después se venderán a diversas empresas. Sobre la base de los pagos efectuados en dicha tarjeta de crédito, los bancos e instituciones de crédito irán elaborando un historial del usuario, el cual se utilizará para autorizar una transacción, para decidir cuándo extender el crédito y para detectar fraudes. Este tipo de procesos requiere de chequeos que suelen resultar bastante complejos, además del uso de criterios variables para poder tomar una decisión final en torno a la autorización de una cierta transacción. Claro que, al manejar enormes volúmenes de información, como los aproximadamente 16 millones de transacciones que Visa Internacional debe verificar diariamente, no resulta nada fácil poder detectar un fraude. Aunque es evidente la necesidad de automatizar procesos como éste, no es del todo obvio incorporar el comportamiento inteligente del ser humano a un programa de computadora que reemplace a un evaluador humano, ya que los sistemas de inteligencia artificial se toman como herramientas de apoyo analítico para el evaluador, mas no como una unidad autosuficiente que por sí sola pueda tomar decisiones.\\

Las redes neuronales artificiales son eficientes en tareas tales como el reconocimiento de patrones, problemas de optimización o clasificación, y se pueden integrar en un sistema de ayuda a la toma de decisiones, pero no son una panacea capaz de resolver todos los problemas: todo lo contrario, son modelos muy especializados que pueden aplicarse en dominios muy concretos.\\

Las redes neuronales emulan la estructura y el comportamiento del cerebro, utilizando los procesos de aprendizaje para buscar una solución a diferentes problemas; son un conjunto de algoritmos matemáticos que encuentran las relaciones no lineales entre conjuntos de datos; suelen ser utilizadas como herramientas para la predicción de tendencias y como clasificadoras de conjuntos de datos. Se denominan neuronales porque están basadas en el funcionamiento de una neurona biológica cuando procesa información.

\subsection{Curvas ROC.}

Una amplia gama de tests diagnósticos reportan sus resultados cuantitativamente, utilizando escalas contínuas. El análisis de curvas ROC ( \textit{receiver operating characteristic curve}) constituye un método estadístico para determinar la exactitud diagnóstica de estos \textit{tests}, siendo utilizadas con tres propósitos específicos: determinar el punto de corte de una escala continua en el que se alcanza la sensibilidad y especificidad más alta, evaluar la capacidad discriminativa del test diagnóstico y comparar la capacidad discriminativa de dos o más \textit{test} diagnósticos que expresan sus resultados como escalas continuas.

\subsection{Lenguaje R.}

R es un conjunto  integrado de \textit{software} de código abierto para el almacenamiento, manipulación, cálculo y visualización de datos para computación y gráficación estadística, puede ser compilado y ejecutado en  en Windows, Mac OS X y otras  plataformas UNIX (como Linux), se distribuye usualmente en formato binario (\url{https://www.r-project.org/about.html}, 2018). El proyecto de \emph{software} R fue iniciado por Robert Gentleman y Ross Ihaka. El lenguaje fue influenciado por  lenguaje S desarrollado originalmente en \textit{Bell Laboratories} por John Chambers y sus colegas. Desde entonces ha evolucionado  para el cálculo estadístico asociado a diversas disciplinas para contextos académicos y comerciales. En R, la unidad fundamental de código compartible es el paquete, el cual agrupa código, datos, documentación y pruebas, y resulta simple de compartir con otros. Para enero del 2015 ya habían más de 6.000 paquetes disponibles en la Red Integral de Archivos de R, conocido comúnmente por su acrónimo CRAN, el cual es el repositorio de paquetes . Esta gran variedad de paquetes es una de las razones por las cuales R es tan exitoso, pues es probable que algún investigador o académico ya haya resuelto un problema en su propio campo usando esta herramienta, por lo que otros usuarios simplemente podrán recurrir a ella para su uso directo o para llamarla en un nuevo código (Wickham,2015). \\

\subsection{Estructura de paquetes en R/RStudio.}

Requerimiento del núcleo (\textit{core})

\begin{enumerate}
  \item  DESCRIPTION: metadatos del package .\\
La tarea del archivo \textit{Description} es de gran importancia ya que es en el donde se registra la metadata, las dependencias que utiliza el paquete, la licencia y el soporte en caso de ocurrir errores con el mismo
La estructura mínima para realizar un paquete en R es la siguiente:

\begin{itemize}
\item Package: mypackage
\item Title: What The Package Does (one line, title case required)
\item Version: 0.1
\item Authors@R: person("First", "Last", email = "first.last@example.com",
\item role = c("aut", "cre"))
\item Description: What the package does (one paragraph)
\item Depends: R (>= 3.1.0)
\item License: What license is it under?
\item LazyData: true
\end{itemize}
  \item \url{R /:} dirección del repositorio donde se encuentra el código del paquete (.R files).\\
Se expondrán las buenas prácticas a la hora de realizar todo nuestro código en R, desde organización de las funciones, estilos de código y nombre de variables 

\textbf{Organizar funciones en R:} aunque puedes organizar los archivos como desees, los dos extremos son malos no colocar todas las funciones en el mismo. archivo y no crear un archivo para para función, aunque si una función es muy grande o tiene mucha documentación se puede dar el caso, los nombres de los archivos tienen que ser significado y deben de terminar en R
\begin{itemize}
\item Bien  
\begin{itemize}
     \item fit\_models.R
     \item utility\_functions.R
  \end{itemize}
\item Mal
   \begin{itemize}
      \item foo.r
      \item stuff.r
    \end{itemize}
 \end{itemize}
Se puede recomendar de acuerdo al número de función utilizar prefijo 

\textbf{Nombres de Objetos:} Los nombres de las Variables y funciones deben de ser en min\'usculas, usar el gui\'on bajo ( \_ ) para separar palabras  
\begin{itemize}
\item Bien  
\begin{itemize}
     \item day\_one
     \item day\_1
  \end{itemize}
\item Mal
   \begin{itemize}
      \item first\_day\_of\_the\_month
      \item DayOne
      \item dayone
      \item djm1
    \end{itemize}
 \end{itemize}
En lo posible no usar nombres de variables existentes esto causar\'a confusi\'on.

\textbf{Espaciado:} Se recomienda colocar espacios alrededor de todos los operadores l\'ogicos y aritm\'eticos (=, +, -, \textless-, etc.). siempre coloque un espacio despu\'es de una coma, y nunca antes de ella.

\begin{itemize}
\item Bien  
\begin{itemize}
     \item average \textless- mean(feet / 12 + inches, na.rm = TRUE)
  \end{itemize}
\item Mal
   \begin{itemize}
      \item average\textless-mean(feet/12+inches,na.rm=TRUE)
   \end{itemize}
 \end{itemize}
 
Hay una pequeña excepci\'on a esta regla: ( :, :: y :::) no necesitan espacios alrededor de ellos.

\begin{itemize}
\item Bien  
\begin{itemize}
     \item x \textless- 1:10
     \item base::get
  \end{itemize}
\item Mal
   \begin{itemize}
      \item x \textless- 1 : 10
     \item base :: get
   \end{itemize}
 \end{itemize}

Dejar un espacio antes del par\'entesis izquierdo, excepto en la llamada a una funci\'on

\begin{itemize}
\item Bien  
\begin{itemize}
     \item if (debug) do(x)
     \item plot(x,y)
  \end{itemize}
\item Mal
   \begin{itemize}
      \item if(debug)do(x)
     \item plot(x, y)
   \end{itemize}
 \end{itemize}

Se Utiliza mas de un espacio es caso que de mejore a la alineaci\'on, por ejemplo:\\
\begin{list}{}{}
\item list(
    \begin{list}{}{} 
       \item total \hspace{3mm}= a + b + c,
       \item mean \hspace{2mm}= (a + b + c) / n
    \end{list}
\item )
\end{list}
No coloque espacios alrededor del c\'odigo entre par\'entesis o corchetes (a menos que haya una coma)
\begin{itemize}
\item Bien  
\begin{itemize}
     \item if (debug)  do(x)
     \item diamonds[5, ]
  \end{itemize}
\item Mal
   \begin{itemize}
      \item if ( debug ) do(x) \textit{\# no espacios alredor de debug}
      \item x[1,] \textit{\# necesita un espacio despues de la coma}
      \item x[1 ,] \textit{\# el espacio va despues de la coma no antes}	   
\end{itemize}
 \end{itemize}

\textbf{Llaves:} Una llave de apertura nunca debe ir en su propia l\'inea y siempre debe ir seguida de un nueva l\'inea. Una llave siempre debe ir en su propia l\'inea, a menos que sea seguida por otra y siempre sangr\'ia el c\'odigo dentro de las llaves
\begin{itemize}
\item Bien  
\begin{itemize}
     \item \begin{list}{}{} 
		\item if (y \textless  \hspace{1mm} 0 \&\&  debug) \{
		\begin{list}{}{}
		\item message(``Y es negativo")
		\end{list}
		\item \}	
	    \end{list}

       \item \begin{list}{}{} 
		\item if (y ==  \hspace{1mm} 0 ) \{
		\begin{list}{}{}
		   \item log(x)
		\end{list}
		\item \} else \{
		\begin{list}{}{}
		  \item y \^~  x
		\end{list}
		\item \}	
	    \end{list}
  \end{itemize}
\item Mal
   \begin{itemize}
     \item \begin{list}{}{} 
		\item if (y \textless  \hspace{1mm} 0 \&\&  debug)
		\item message(``Y es negativo")
	    \end{list}

       \item \begin{list}{}{} 
		\item if (y ==  \hspace{1mm} 0) \{
		\begin{list}{}{}
		   \item log(x)
		\end{list}
		\item \}
		\item else \{
		\begin{list}{}{}
		  \item y \^~  x
		\end{list}
		\item \}	
	    \end{list}   
\end{itemize}
 \end{itemize}

Sentencias  muy cortar esta bien dejarla en la misma l\'inea.\\
if(y \textless \hspace{1mm} 0 \&\& debug) message(``Y es negativo")\\

\textbf{Longitud de L\'inea:} cada l\'inea debe de llevar m\'aximo 80 carateres, si se queda sin espacio es recomendable utilzar una funci\'on separada\\

\textbf{Sangria:} Utilize sangria de 2 espacios, nunca use tablulador o multiples tabuladores o espacios. la unica expeci\'on es cuando se define una sentencia en multiples l\'ineas.\\
\begin{tabular}{ccc}
long\_function\_name \textless- function(& a = ``a long argument", \\ 
 &  b = ``another argument", \\
 &  b = ``another argument", \\
\end{tabular}
\newline

\textbf{Asignaci\'on:} Usar el \textless-, y no =
\begin{itemize}
\item Bien  
\begin{itemize}
     \item x \textless- 5
  \end{itemize}
\item Mal
   \begin{itemize}
      \item x = 5
   \end{itemize}
 \end{itemize}

  \item man/: documentación.\\
  \item NAMESPACE: específica que objetos conforman el paquete.\\
\end{enumerate}
\textbf{Comentarios:} Comente tu codig\'o, el comentario comienza \#, los comentarios deben de explicar el porque, no el que.\\ use los caracteres (-) y (=) para separar lineas\\
{\# Load data - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -}\\
{\# Plot data - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -}\\


\subsection{RStudio.}

RStudio es un ambiente de desarrollo integrado (\textit{Integrated Development Environment}, IDE) que ofrece herramientas de desarrollo vía consola, editor de sintaxis que apoya la ejecución de código, así como herramientas para el trazado, la depuración y la gestión del espacio de trabajo.  RStudio está disponible para Windows, Mac y Linux o para navegadores conectados a RStudio Server o RStudio Server Pro (Debian / Ubuntu, RedHat / CentOS, y SUSE Linux) (\url{https://www.rstudio.com/about/}, 2018).
 


